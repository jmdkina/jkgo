package jklog

import (
	"fmt"
	"io"
	"log"
	"os"
	"sync"
)

// These flags define which text to prefix to each log entry generated by the Logger.
const (
	// Bits or'ed together to control what's printed. There is no control over the
	// order they appear (the order listed here) or the format they present (as
	// described in the comments).  A colon appears after these items:
	//	[log] 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
	Ldate         = log.Ldate                  // the date: 2009/01/23
	Ltime         = log.Ltime                  // the time: 01:23:23
	Lmicroseconds = log.Lmicroseconds          // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile     = log.Llongfile              // full file name and line number: /a/b/c/d.go:23
	Lshortfile    = log.Lshortfile             // final file name element and line number: d.go:23. overrides Llongfile
	LstdFlags     = log.LstdFlags | Lshortfile // initial values for the standard logger
)

//日志级别
const (
	LEVEL_DISABLE = 0 //关闭日志功能
	LEVEL_DEBUG   = 1 << iota
	LEVEL_NOTICE
	LEVEL_INFO
	LEVEL_WARN
	LEVEL_ERROR
	LEVEL_CRITICAL
	LEVEL_PANIC
)

const (
	LEVEL_FATAL = "[FATAL]"
	LEVEL_ALL   = LEVEL_DEBUG | LEVEL_NOTICE | LEVEL_INFO | LEVEL_WARN | LEVEL_ERROR | LEVEL_CRITICAL | LEVEL_PANIC

	//默认日志级别为
	//LEVEL_DEFAULT = LEVEL_INFO | LEVEL_WARN | LEVEL_ERROR | LEVEL_CRITICAL | LEVEL_PANIC
	LEVEL_DEFAULT   = LEVEL_ALL
	LEVEL_MUCH      = LEVEL_NOTICE | LEVEL_INFO | LEVEL_WARN | LEVEL_ERROR | LEVEL_CRITICAL | LEVEL_PANIC
	LEVEL_IMPORTANT = LEVEL_ERROR | LEVEL_CRITICAL | LEVEL_PANIC
)

var (
	logPrefixs = map[int]string{
		LEVEL_DEBUG:    "[DEBUG]",
		LEVEL_NOTICE:   "[NOTICE]",
		LEVEL_INFO:     "[INFO]",
		LEVEL_WARN:     "[WARN]",
		LEVEL_ERROR:    "[ERROR]",
		LEVEL_CRITICAL: "[CRITICAL]",
		LEVEL_PANIC:    "[PANIC]",
	}
)

type Logger struct {
	*log.Logger
	mu    sync.Mutex
	level int
	name  string
}

func New(out io.Writer, prefix string, flag int) *Logger {
	return &Logger{
		Logger: log.New(out, prefix, flag),
		level:  LEVEL_DEFAULT,
		name:   prefix,
	}
}

func (l *Logger) SetOutput(w io.Writer) {
	l.mu.Lock()
	prefix := l.Prefix()
	flags := l.Flags()
	levels := l.Levels()
	l.mu.Unlock()
	*l = Logger{
		Logger: log.New(w, prefix, flags),
		level:  levels,
	}
}

func (l *Logger) SetLevel(level int) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.level = level
}

func (l *Logger) Levels() int {
	return l.level
}

func (l *Logger) Output(calldepth int, s string) error {
	return l.Logger.Output(calldepth, s)
}

func (l *Logger) noneprint(v ...interface{}) {
	s := fmt.Sprint(v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	flag := l.Logger.Flags()
	l.Logger.SetFlags(0)
	l.Logger.Output(3, s)
	l.Logger.SetFlags(flag)
}

func (l *Logger) noneprintf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	flag := l.Logger.Flags()
	l.Logger.SetFlags(0)
	l.Logger.Output(3, s)
	l.Logger.SetFlags(flag)
}

func (l *Logger) noneprintln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	flag := l.Logger.Flags()
	l.Logger.SetFlags(0)
	l.Logger.Output(3, s)
	l.Logger.SetFlags(flag)
}

func (l *Logger) print(prefix string, v ...interface{}) {
	//又包了2层
	localCalldepth := 2 + 2
	s := fmt.Sprint(v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	l.SetPrefix(prefix)
	l.Output(localCalldepth, s)
}

func (l *Logger) println(prefix string, v ...interface{}) {
	//又包了2层
	localCalldepth := 2 + 2
	s := fmt.Sprintln(v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	l.SetPrefix(prefix)
	l.Output(localCalldepth, s)
}

func (l *Logger) printf(prefix string, format string, v ...interface{}) {
	//又包了2层
	localCalldepth := 2 + 2
	s := fmt.Sprintf(format, v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	l.SetPrefix(prefix)
	l.Output(localCalldepth, s)
}

func (l *Logger) stdprint(v ...interface{}) {
	s := fmt.Sprint(v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	l.Logger.Output(3, s)
}

func (l *Logger) stdprintf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	l.Logger.Output(3, s)
}

func (l *Logger) stdprintln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	l.mu.Lock()
	defer l.mu.Unlock()
	l.Logger.Output(3, s)
}

func (l *Logger) Print(v ...interface{}) {
	l.stdprint(v)
}

func (l *Logger) Println(v ...interface{}) {
	l.stdprintln(v)
}

func (l *Logger) Printf(format string, v ...interface{}) {
	l.stdprintf(format, v)
}

func (l *Logger) Panic(v ...interface{}) {
	if LEVEL_PANIC&l.level == 0 {
		return
	}

	l.print(logPrefixs[LEVEL_PANIC]+" ", v...)
	panic(fmt.Sprint(v...))
}

func (l *Logger) Panicln(v ...interface{}) {
	if LEVEL_PANIC&l.level == 0 {
		return
	}

	l.println(logPrefixs[LEVEL_PANIC]+" ", v...)
	panic(fmt.Sprintln(v...))
}

func (l *Logger) Panicf(format string, v ...interface{}) {
	if LEVEL_PANIC&l.level == 0 {
		return
	}

	l.printf(logPrefixs[LEVEL_PANIC]+" ", format, v...)
	panic(fmt.Sprintf(format, v...))
}

func (l *Logger) Fatal(v ...interface{}) {
	l.print(LEVEL_FATAL+" ", v...)
	os.Exit(1)
}

func (l *Logger) Fatalln(v ...interface{}) {
	l.println(LEVEL_FATAL+" ", v...)
	os.Exit(1)
}

func (l *Logger) Fatalf(format string, v ...interface{}) {
	l.printf(LEVEL_FATAL+" ", format, v...)
	os.Exit(1)
}
